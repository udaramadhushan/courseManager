"use strict";
const typescript_1 = require("typescript");
const { get, ownKeys, set } = Reflect;
// type guards helpers
const { isArray } = Array;
const isObject = (v) => Object.prototype.toString.call(v) === '[object Object]';
/**
 * A 'good enough' recursive Object.assign like function
 * Properties from sources are add or overwritten on target.
 * If the value is a object, then recursion is applied
 * If the value is an array, then concatenation occurs
 * @param {object} target The target object to mutate.
 * @param {object[]} sources one or more objects to assign.
 */
const deepAssign = (target, ...sources) => {
    for (const source of sources) {
        const keys = ownKeys(source);
        for (const key of keys) {
            const targetValue = get(target, key);
            if (source.hasOwnProperty(key)) {
                const value = get(source, key);
                if (isArray(value)) {
                    set(target, key, isArray(targetValue) ? [...targetValue, ...value] : value);
                }
                else if (isObject(value)) {
                    set(target, key, deepAssign(isObject(targetValue) ? targetValue : {}, value));
                }
                else if (typeof value !== 'undefined') {
                    set(target, key, value);
                }
            }
        }
    }
    return target;
};
/**
 * Transpiles a TypeScript file into a valid Apps Script file.
 * @param {string} source The TypeScript source code as a string.
 * @param {TranspileOptions} transpileOptions custom transpile options.
 * @see https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API
 */
const ts2gas = (source, transpileOptions = {}) => {
    /** semaphore for emitting dummy `module.exports` */
    let addDummyModule = false;
    // Node filters
    /**
     * Filter any expression statement assigning to 'exports["default"]'
     */
    const exportsDefaultNodeFilter = (node) => typescript_1.isExpressionStatement(node) &&
        typescript_1.isBinaryExpression(node.expression) && // is it a binary expression
        typescript_1.isPropertyAccessExpression(node.expression.left) &&
        typescript_1.isIdentifier(node.expression.left.expression) && // is it 'exports'
        typescript_1.idText(node.expression.left.expression) === 'exports' &&
        typescript_1.isIdentifier(node.expression.left.name) && // is it 'default'
        typescript_1.idText(node.expression.left.name) === 'default' &&
        node.expression.operatorToken.kind === typescript_1.SyntaxKind.EqualsToken && // '='
        typescript_1.isIdentifier(node.expression.right);
    /**
     * Filter any added `exports.__esModule` expression statement
     */
    const exportEsModuleNodeFilter = (node) => typescript_1.isExpressionStatement(node) &&
        node.pos === -1 &&
        node.end === -1 && // hint it was added by tranpiler
        typescript_1.isBinaryExpression(node.expression) &&
        typescript_1.isPropertyAccessExpression(node.expression.left) &&
        typescript_1.isIdentifier(node.expression.left.expression) &&
        typescript_1.idText(node.expression.left.expression) === 'exports' &&
        typescript_1.idText(node.expression.left.name) === '__esModule';
    /**
     * Filter any `export`...`from` declaration
     */
    const exportFromNodeFilter = (node) => typescript_1.isExportDeclaration(node) && !!node.getChildren().find((e) => e.kind === typescript_1.SyntaxKind.FromKeyword);
    /**
     * Filter any import declaration
     */
    const importNodeFilter = (node) => typescript_1.isImportEqualsDeclaration(node) || typescript_1.isImportDeclaration(node);
    /**
     * Filter any identifier
     */
    const identifierFilter = (node) => typescript_1.isIdentifier(node);
    // Transformers
    /**
     *  Create a commented-out statement
     * @param {Node} node The node to comment-out.
     */
    const createCommentedStatement = (node) => {
        const ignoredNode = typescript_1.createNotEmittedStatement(node);
        typescript_1.addSyntheticTrailingComment(ignoredNode, typescript_1.SyntaxKind.SingleLineCommentTrivia, node.getText().replace(/\n/g, '\\n'));
        return ignoredNode;
    };
    // `before:` transformer factories
    /**
     * Create a 'before' Transformer callback function
     * It use 'createCommentedStatement' to comment-out filtered node
     * @param {NodeFilter} nodeFilter The node visitor used to transform.
     */
    const ignoreNodeBeforeBuilder = (nodeFilter) => (context) => {
        const visitor = (node) => nodeFilter(node) ? createCommentedStatement(node) : typescript_1.visitEachChild(node, visitor, context);
        return (sourceFile) => typescript_1.visitNode(sourceFile, visitor);
    };
    /**
     * Create a 'before' Transformer callback function
     * It use applies the 'NoSubstitution' flag on every node
     * @param {NodeFilter} nodeFilter The node visitor used to transform (unused here).
     */
    const noSubstitutionBeforeBuilder = (nodeFilter) => (context) => {
        const visitor = (node) => {
            if (nodeFilter(node) && // node kind is Identifier
                // do not process if parent kind is EnumDeclaration
                !(node.parent && typescript_1.isEnumDeclaration(node.parent))) {
                typescript_1.setEmitFlags(node, typescript_1.EmitFlags.NoSubstitution);
            }
            return typescript_1.visitEachChild(node, visitor, context);
        };
        return (sourceFile) => typescript_1.visitNode(sourceFile, visitor);
    };
    // `after:` transformer factories
    /**
     * Create an 'after' Transformer callback function to ignore filtered nodes
     * @param {SyntaxKind} kind the kind of node to filter.
     * @param {NodeFilter} nodeFilter The node visitor used to transform.
     */
    const ignoreNodeAfterBuilder = (kind, nodeFilter) => (context) => {
        const previousOnSubstituteNode = context.onSubstituteNode;
        context.enableSubstitution(kind);
        context.onSubstituteNode = (hint, node) => {
            node = previousOnSubstituteNode(hint, node);
            if (nodeFilter(node)) {
                /** Do not emit this node */
                // node = createEmptyStatement();
                node = typescript_1.createNotEmittedStatement(node);
                // node = createCommentedStatement(node);
            }
            return node;
        };
        return (sourceFile) => sourceFile;
    };
    // Before transpiling, apply these touch-ups:
    const noSubstitution = noSubstitutionBeforeBuilder(identifierFilter);
    // ## Imports
    // Some editors (like IntelliJ) automatically import identifiers.
    // Individual imports lines are commented out
    // i.e. import GmailMessage = GoogleAppsScript.Gmail.GmailMessage;
    const ignoreImport = ignoreNodeBeforeBuilder(importNodeFilter);
    // ## Exports
    // ignore exports like `export * from 'file'`
    const ignoreExportFrom = ignoreNodeBeforeBuilder(exportFromNodeFilter);
    // After transpiling, apply these touch-ups:
    // ## exports.__esModule
    // Remove all lines that have exports.__esModule = true
    // @see https://github.com/Microsoft/TypeScript/issues/14351
    const removeExportEsModule = ignoreNodeAfterBuilder(typescript_1.SyntaxKind.ExpressionStatement, exportEsModuleNodeFilter);
    // Remove default exports
    // (Transpiled `exports["default"]`)
    const removeExportsDefault = ignoreNodeAfterBuilder(typescript_1.SyntaxKind.ExpressionStatement, exportsDefaultNodeFilter);
    const detectExportNodes = (context) => (sourceFile) => {
        const visitor = (node) => {
            if (addDummyModule) {
                // no need to look further
                return node;
            }
            if (typescript_1.isIdentifier(node) && typescript_1.idText(node) === 'exports') {
                addDummyModule = true;
            }
            return typescript_1.visitEachChild(node, visitor, context);
        };
        return typescript_1.visitNode(sourceFile, visitor);
    };
    const addDummyModuleNodes = () => (sourceFile) => addDummyModule
        ? typescript_1.updateSourceFileNode(sourceFile, [
            typescript_1.createVariableStatement(undefined, typescript_1.createVariableDeclarationList([
                typescript_1.createVariableDeclaration(typescript_1.createIdentifier('exports'), undefined, typescript_1.createBinary(typescript_1.createIdentifier('exports'), typescript_1.createToken(typescript_1.SyntaxKind.BarBarToken), typescript_1.createObjectLiteral([], false))),
            ], typescript_1.NodeFlags.None)),
            typescript_1.createVariableStatement(undefined, typescript_1.createVariableDeclarationList([
                typescript_1.createVariableDeclaration(typescript_1.createIdentifier('module'), undefined, typescript_1.createBinary(typescript_1.createIdentifier('module'), typescript_1.createToken(typescript_1.SyntaxKind.BarBarToken), typescript_1.createObjectLiteral([typescript_1.createPropertyAssignment(typescript_1.createIdentifier('exports'), typescript_1.createIdentifier('exports'))], false))),
            ], typescript_1.NodeFlags.None)),
            ...sourceFile.statements,
        ])
        : sourceFile;
    /**
     * These settings can be overridden
     */
    const defaults = {
        compilerOptions: {
            experimentalDecorators: true,
            noImplicitUseStrict: true,
            target: typescript_1.ScriptTarget.ES3,
        },
    };
    /**
     * These the settings are always used and cannot be overridden
     *
     * Extra compiler options that will unconditionally be used by this function are
     * - isolatedModules = true
     * - noLib = true
     * - noResolve = true
     */
    const statics = {
        compilerOptions: {
            emitDeclarationOnly: false,
            module: typescript_1.ModuleKind.None,
        },
        transformers: {
            before: [noSubstitution, ignoreExportFrom, ignoreImport],
            after: [removeExportEsModule, removeExportsDefault, detectExportNodes, addDummyModuleNodes],
        },
    };
    // keep only override-able properties
    if (typeof transpileOptions === 'object') {
        const { compilerOptions, renamedDependencies } = transpileOptions;
        transpileOptions = { compilerOptions, renamedDependencies };
    }
    else {
        transpileOptions = {};
    }
    // merge properties in order for proper override
    transpileOptions = deepAssign({}, // safe to mutate
    defaults, // default (override-able)
    transpileOptions, // user override
    statics);
    // Transpile (cf. https://www.typescriptlang.org/docs/handbook/compiler-options.html)
    const result = typescript_1.transpileModule(source, transpileOptions);
    // # Clean up output (multiline string)
    let output = result.outputText;
    // ## Exports
    // Exports are transpiled to variables 'exports' and 'module.exports'
    const packageJson = require('../package.json'); // ugly hack
    // Include an exports object in all files.
    output = `// Compiled using ${packageJson.name} ${packageJson.version} (TypeScript ${typescript_1.version})
${output}`;
    return output;
};
module.exports = ts2gas;
